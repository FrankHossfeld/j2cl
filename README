Rough attempt at some build tools:

 * build.sh - production compile strawman, showing a process that could be used on each dependency to prepare its transpiled
JS, and collect them all and build into a final optimized result
 * devmode.sh - "dev mode" strawman - loops, while "watching" for changes in source java files, resulting in intermediate
JS, and finally minimally compiled JS to load in the browser.
 * bootstrap.sh - package up the various vmbootstrap, nativebootstrap, and closure-library guts required in a j2cl app.
 * DevMode.main() - Faster/smarter strawman for dev mode. Adds the ability to correctly zip .native.js. Keeps the JVM hot
 between builds, dramatically improving the performance of J2CL (but not jscomp. work in progress there.)

The first two scripts assume that everyone loves maven, and that you plan to build the
https://github.com/vertispan/connected/tree/no-gwt-user project, with just part of elemental2, and no other dependencies

The DevMode class is more configurable, supporting a classpath for java compilation, and another for jszips, so you can pass
in any list of jars and jszips you wish. Multiple source directories can be specified, a classes directory to store java
bytecode in, a directory to push compiled output to, and the name of the entrypoint class (which is assumed to have a
working .native.js to actually launch it, or the html page will have to launch it).

Prerequisites:
 * Project that can be compiled in J2CL
 * .native.js in that project to either export symbols, or start the app. Running in BUNDLE mode is differently finicky, we're
 going to want to standardized this...
 * List of jszip and jar entries for their respective classpath. The java classpath list probably should contain the
 jre.jar, and the js classpath should probably contain the bootstrap.js.zip and jre.js.zip.



---

Build process, and assumptions:

Assuming:
 * No globally consistent version of j2cl (requires local cache clearing as needed)
   * No or partially distributed `.j2.zip`s (would require versioning by j2cl, re-releasing by entire ecosystem for any incremental release)
 * Closure will continue to error on duplicate declared modules
 * External (not in jre.jar) "supersource" still matters (i.e. gwt will not accept any arbitrary emulation)
 * Dependencies which supersource themselves still are permitted to be used


Steps:
 * unpack all .js.zip that are provided (may be as little as jre.js.zip and bootstrap.js.zip)
 * precompile all source jar dependencies (possibly checking a cache and skipping some if up to date)
   * this includes preprocessing, since the preprocessor is tied to the compiler and may change
   * this also required de-duping "self-supersourced" classes, as j2cl doesn't allow dups
 * unpack all upstream .js.zips to a single dir in order of java classpath (allowing some types to override others)
 * (if incremental, or if we don't assume already javac'd for apt) javac all current sources
 * discover, skip any types which are "self-supersourced" within the project
 * transpile all current sources and current generated sources to the same dir as dependency output
 * (missing) resolve properties, permutations
 * Run closure on all generated js, including entrypoint and defines
 * (missing) link permutations